# Abstraction


## 1. Introduction

In the context of Object-Oriented Programming, abstraction can be defined as the distinctive characteristics of an object that differentiate it from other types of objects, thus establishing conceptual boundaries between them.

The primary objective of abstraction is to enable us to represent complex concepts in a simplified manner, emphasizing the relevant aspects while concealing internal details about how the object functions.

For example, let's consider the task of driving a car. You are aware of the following basic steps:

1. Sit in the driver's seat.
2. Fasten your seat belt.
3. Place the gear in neutral.
4. Insert the key and start the engine.
5. Engage the clutch, shift the gear and allow the car to move.

Although these processes may appear straightforward, they actually involve much more intricate mechanisms. The driver's seat is securely attached to the car floor in a specific manner, the seat belt incorporates a specialized mechanism to ensure safe fastening, the gear system possesses a complex mechanism that may be unfamiliar to you, the key possesses a specific configuration that activates an electronic circuit responsible for starting the engine, and so on.

As a driver, you are not required to possess an in-depth understanding of these details in order to operate a car. Generally speaking, you can simply take them for granted.

## 2. Classes and objects

We can define a class as a concept that specifies the shared characteristics of a group of objects. An object, on the other hand, refers to any entity associated with a particular class. In C++, when declaring classes and objects, we must adhere to a specific syntax, which is as follows:

```cpp
// Declare a class
class ClassName
{
	private:
		// List of private class members...
	public:
		// List of public class members...
	protected:
		// List of protected class members...
};

int main()
{
	// Create an object from a class
	ClassName objectName;
	
	// Create another object from the same class
	ClassName anotherObject;
	
	return 0;
}
```

As you can observe, we can instantiate a class (i.e., create an object) simply by invoking the class name followed by the desired name for the object. Moreover, we have the flexibility to create multiple instances as required to ensure the functionality of our program


## 3. Attributes and methods

When defining the behavior of a class, we utilize two distinct types of components:

- Attributes (also known as "variable members"): These encompass constants and/or variables that establish the fundamental characteristics of an object.

- Methods (also referred to as "member functions"): These are functions that delineate the actions typically performed by an object belonging to the class.

Let's examine these components within a contextual framework:

```cpp
#include <iostream>

class ClassName
{
	public:
		int integerVariable = 4;
		bool booleanVariable = true;
		void objectMethod() { std::cout << "I have called a method" << std::endl; }
};

int main()
{
	ClassName myObject;
	
	// Access its variables and print them in console
	std::cout << myObject.integerVariable << std::endl;
	std::cout << myObject.booleanVariable << std::endl;
	
	// Call the method
	myObject.objectMethod();
	
	return 0;	
}
```

The output generated by executing this script is:

```
4
true
I have called a method
```

As you can observe, I can access the object's attributes and methods by referencing the object name followed by a dot and the name of the desired attribute or method.

***Note:** In order to accomplish this, the attributes and methods must be declared as public. It is not possible to directly access private members by calling them. Further details about this can be found in the topic of Encapsulation.*

## 4. Data abstraction

As mentioned earlier, there are numerous internal details of an object that we neither know nor need to know about. This is intentional and serves a valuable purpose. Consider the scenario where we had to possess intricate knowledge of a car engine's specific details just to operate the vehicle—only engineers would be capable of driving. Additionally, data abstraction operates in a manner that safeguards against unintended modifications to the internal characteristics of a class, preventing unwanted or undesirable changes.

Nevertheless, it would be advantageous if we could access these internal details without compromising the proper functioning of an object. Allow me to provide an example:

```cpp
#include <iostream>

class ClassName
{
	private:
		int privateVariable = 10;
		
	public:
		// Access the private
		int classMethod() { return privateVariable; }
};

int main()
{
	// Create an object from a class
	ClassName myObject;
	
	// Access and store the private attribute
	int objectVariable = myObject.classMethod();
	
	// Print it
	std::cout << objectVariable << std::endl; // Prints '10' in console
	
	return 0;
}
```


Success! We have successfully obtained access to the internal details of an object. In practice, we accomplish this by utilizing what is commonly known as *getters* and *setters*—methods that retrieve and modify values of private and protected class attributes. Allow me to demonstrate:

```cpp
class ClassName
{
	private:
		int privateVariable = 10;
		
	public:
		// Getter
		int getPrivateVariable() { return privateVariable; }
		
		// Setter
		void setPrivateVariable(int newValue) { privateVariable = newValue; }
};
```

The getter method retrieves the value of a private attribute, while the setter method updates the private attribute with a new value passed as a parameter to the function. This is the fundamental functionality of getters and setters. Do you get it? (Hahaha... *get it*...)

## 5. Constructors and destructors

The current approach we have used to define objects does not allow us to dynamically establish their initial state as soon as we create an instance of a class. What if I wanted to create an object where `privateVariable` is initially set to 8 instead of 10?

While it is possible to create the object and then use `myObject.setPrivateVariable(8)`, it becomes inefficient when dealing with multiple private attributes. For instance, if the object has five private attributes, would I need to call five setters? What if I need to set ten or even a hundred attributes? This approach lacks efficiency. That's precisely why we have a special public method called a constructor.

Additionally, we have another special method called a destructor. When we create an object, it occupies a portion of memory. Once the program finishes execution, the destructor method is invoked to free up the memory used by the object. Memory management can be a complex topic, and I recommend further reading to gain a better understanding.

Allow me to demonstrate the correct syntax for these methods:

```cpp
class ClassName
{
	private:
		int integerVariable;
		bool booleanVariable;
	public:
		// Constructor method
		ClassName()
		{
			this->integerVariable = 10;		// Setting the integer to 10
			this->booleanVariable = true;	// Setting the boolean to true
		}
	
		// Destructor method
		~ClassName() = default; // I'm using the default constructor generated by the compiler
};
```

Success! We have successfully utilized a constructor and covered the implementation of a destructor method. While this is fantastic, let's make it a tad more intricate. So far, we have passed hardcoded values to the constructor, but what if we desire the flexibility to provide different values as per our requirements? In such cases, we can pass these values as parameters to the constructor. Allow me to demonstrate:

```cpp
// Constructor
ClassName(int integer, bool boolean)
{
	this->integerVaruable = integer;
	this->booleanVariable = boolean;
}
```

## 6. Inheritance and Polymorphism as advanced concepts related to Abstraction

So far, we have provided a brief introduction to Object-Oriented Programming. Abstraction becomes more intricate as it intertwines with other concepts such as inheritance and polymorphism.

Inheritance enables the creation of class hierarchies, facilitating the sharing of common behaviors among classes. On the other hand, polymorphism allows you to treat objects from derived classes as objects of their own base class. For further information on inheritance and polymorphism, you can refer to resources available here and here.

That concludes our discussion for now. I trust you have found this article to be informative and helpful!


## Final notes

This article was created by Facundo Martínez © 2023. It is licensed under CC BY-NC-SA 4.0

If you have found it beneficial, kindly consider [supporting me on Ko-Fi](https://ko-fi.com/biocoder). Your contribution will assist me in creating more high-quality free content for the benefit of all. 

